<resources>
    <string name="app_name">AlgoVisualiser</string>
    <string name="main_title">AndroidAlgoVisualiser</string>
    <string name="main_button_label_1">Breadth First Search</string>
    <string name="main_button_label_2">Depth First Search</string>
    <string name="main_button_label_3">N-Queens</string>
    <string name="mainSelect">Select an Algorithm</string>


    <string name="BFSTitle">Breadth First Search</string>
    <string name="BFSDescription">
        Breadth first search is an algorithm for traversing a graph.

\n\nWe first start at one node, and add all of the node\'s neighbours to a queue. In turn we then check each of the neighbours and add their neighbours to the queue. This has an effect of searching through in layers. First we are checking every node distance 1 from the start, then every node distance 2 from the start until we find the final node. We also keep track of which nodes we have visited, and don\'t visit nodes that we have already been to.

\n\nThis algorithm contrasts with the depth first search algorithm which uses a stack.

    </string>
    <string name="BFSParam1">Start Position</string>
    <string name="BFSParam2">End Position</string>
    <string name="BFSAction">Search</string>

    <string name="DFSTitle">Depth First Search</string>
    <string name="DFSDescription">
        Depth first search is an algorithm for traversing a graph.

\n\nWe first start at one node and add all of the node\'s neighbours to a stack. In turn we pop a node from the stack and add the node\'s neighbours to the stack. This repeats until we have found the final node, or the stack is empty (all nodes have been searched). We also keep track of which nodes we have visited, and don\'t visit nodes that we have already been to.

\n\nThis algorithm contrasts with the breadth first search algorithm which uses a queue.

    </string>
    <string name="DFSParam1">Start Position</string>
    <string name="DFSParam2">End Position</string>
    <string name="DFSAction">Search</string>

    <string name="NQUEENSTitle">N-Queens</string>
    <string name="NQUEENSDescription">
        The problem is essentially to place N queens on a chessboard of size N. Such that no two queens are \'attacking\' each other by normal chess rules. There is a solution for all natural numbers apart from 2 and 3. This only renders up to n=9, but will solve larger boards.

\n\nThe solution is a backtracking algorithm. The program will place a queen wherever it can, then when it runs into a situation where it cannot place another queen it backtracks to an earlier point, trying a different permutation.
\nThis algorithm will always find a solution but can take a long time.

\n\nIn the code below you can see that the \'recursionQueen()\' method is called recursively. Each time the method is called, the currentX variable is increased by 1.

    </string>
    <string name="NQUEENSParam1">Board Size(4-8 works best)</string>
    <string name="NQUEENSParam2">Animation Delay</string>
    <string name="NQUEENSAction">Find</string>


</resources>